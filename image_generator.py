import numpy as npimport sysimport osimport mathimport cv2from open3d import *from helper_functions import read_calib_file, read_labelpredict_dir = "/home/kangning/PycharmProjects/visualization/predict/"image_dir = "/home/kangning/PycharmProjects/visualization/image/"lidar_dir = "/home/kangning/PycharmProjects/visualization/velodyne/"calib_dir = "/home/kangning/PycharmProjects/visualization/calib/"trajectory_dir = "/home/kangning/PycharmProjects/visualization/camera_trajectory"#predict_dir = "/home/kangning/Documents/Masterarbeit/frustum-pointnets/train/detection_results_v1/data/"#image_dir = "/home/kangning/Documents/Masterarbeit/frustum-pointnets/dataset/KITTI/object/training/image_2/"#lidar_dir = "/home/kangning/Documents/Masterarbeit/frustum-pointnets/dataset/KITTI/object/training/velodyne/"#calib_dir = "/home/kangning/Documents/Masterarbeit/frustum-pointnets/dataset/KITTI/object/training/calib/"#lidar_image_dir = "/home/kangning/PycharmProjects/visualization/new_image/"#trajectory_dir = "/home/kangning/PycharmProjects/visualization/camera_trajectory/"height = 850width = 1700roi_height = 20roi_width = 40def ScaleRows(z):    return int((height/2) + math.floor(z* (height / (2* roi_height))))   # Scaling z from 0 to 850def ScaleCols(x):    return int((width/2) + math.floor(x*(width / (2* roi_width))))   # Scaling x from 0 to 1700def ScaleY(y):    return math.floor((y +3) *25)predict_names = os.listdir(predict_dir)indexes = []for index,predict_name in enumerate(predict_names):    #index = predict_name.split(".txt")[0]    sequence = predict_name.split(".txt")[0]    print("index",index)    print("sequence",sequence)    #print (index)    new_image = np.zeros((height,width,3),np.uint8)    indexes.append(sequence)    img_path = image_dir + sequence + ".png"    image = cv2.imread(img_path,-1)    lidar_path = lidar_dir + sequence + ".bin"    #print(lidar_path)    point_cloud = np.fromfile(lidar_path, dtype=np.float32).reshape(-1, 4)  # point cloud channel is x,y,z,reflectance    #### Remove points that locate behind camera    #point_cloud = point_cloud[point_cloud[:, 0] > -2.5, :]    # tr_velo_to_cam dot r0_rect    # using homogeneous transformation    calib_path = calib_dir + sequence + ".txt"    camera_trajectory = trajectory_dir + sequence + ".json"    calib = read_calib_file(calib_path)    P2 = calib['P2']    # print(P2)    # print(centers_list[0])    Tr_velo_to_cam_original = calib['Tr_velo_to_cam']    R0_rect_original = calib['R0_rect']    R0_rect = np.eye(4)    '''    array([[1., 0., 0., 0.],           [0., 1., 0., 0.],           [0., 0., 1., 0.],           [0., 0., 0., 1.]])    '''    R0_rect[0:3, 0:3] = R0_rect_original    Tr_velo_to_cam = np.eye(4)    Tr_velo_to_cam[0:3, :] = Tr_velo_to_cam_original    point_cloud_xyz = point_cloud[:, 0:3]    point_cloud_xyz_homo = np.ones((point_cloud.shape[0], 4))    point_cloud_xyz_homo[:, 0:3] = point_cloud[:, 0:3]    point_cloud_camera_non_rec = np.dot(Tr_velo_to_cam, point_cloud_xyz_homo.T)    point_cloud_camera_rect = np.dot(R0_rect, point_cloud_camera_non_rec).T  # 4 channels, homogeneous coordinates    # Homogeneous to cartesian: convert point_cloud_camera_rect(homogeneous coordinates into cartesian coordinates/point_cloud_xyz_camera )    point_cloud_xyz_camera = np.zeros((point_cloud_camera_rect.shape[0], 3))  # 3 channels , cartesian coordinates    point_cloud_xyz_camera[:, 0] = point_cloud_camera_rect[:, 0] / point_cloud_camera_rect[:, 3]    point_cloud_xyz_camera[:, 1] = point_cloud_camera_rect[:, 1] / point_cloud_camera_rect[:, 3]    point_cloud_xyz_camera[:, 2] = point_cloud_camera_rect[:, 2] / point_cloud_camera_rect[:, 3]    pcd = open3d.PointCloud()    pcd.points = open3d.Vector3dVector(point_cloud_xyz_camera)    #print(pcd.points[0])    for point in pcd.points:        z = point[0]        y = point[1]        x = point[2]        if math.fabs(z) <= roi_height and math.fabs(x) <= roi_width and y > -5 and y < 10:            #new_image[ScaleRows(z) , ScaleCols(x)] = [ScaleY(y),255, 255]            new_image[ScaleRows(z), ScaleCols(x)] = [255, ScaleY(y), 255]    new_image = cv2.cvtColor (new_image,cv2.COLOR_HSV2BGR)    test_path = "/home/kangning/Desktop/top_view/"    #cv2.imwrite(test_path + sequence + ".png", new_image )